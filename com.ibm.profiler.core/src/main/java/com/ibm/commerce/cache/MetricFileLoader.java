package com.ibm.commerce.cache;

/*
 *-----------------------------------------------------------------
 * IBM Confidential
 *
 * OCO Source Materials
 *
 * WebSphere Commerce
 *
 * (C) Copyright IBM Corp. 2013, 2015
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has
 * been deposited with the U.S. Copyright Office.
 *-----------------------------------------------------------------
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to load performance metrics from a file.
 */
public class MetricFileLoader {


    private static final String VALID_CHARACTERS_BEFORE_AND_AFTER_A_NUMBER_REGEX = "[, \n\t\r();=<>!]";

    // private static final String NUMBER_REGEX = "-?[0-9]{1,}\\.?[0-9]*";

    private static final String AFTER_NUMBER_LOOK_AHEAD_REGEX = "(?=" +
        VALID_CHARACTERS_BEFORE_AND_AFTER_A_NUMBER_REGEX + "|$)";

    private static final String BEFORE_NUMBER_LOOK_BEHIND_REGEX = "(?<=(" +
        VALID_CHARACTERS_BEFORE_AND_AFTER_A_NUMBER_REGEX + "|^))";

    private static final String NUMBER_REGEX = BEFORE_NUMBER_LOOK_BEHIND_REGEX +
        "-?[0-9]+(\\.[0-9]*)?([eE][+-]?[0-9+])?" + AFTER_NUMBER_LOOK_AHEAD_REGEX;

    private static final String QUOTED_STRING_REGEX = "'([^']|'')*'";

    private static final String UUID_REGEX = BEFORE_NUMBER_LOOK_BEHIND_REGEX +
        "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" + AFTER_NUMBER_LOOK_AHEAD_REGEX;
    
    /** copyright */
    public static final String COPYRIGHT = com.ibm.commerce.copyright.IBMCopyright.SHORT_COPYRIGHT;

    /**
     * Class name
     */
    private static final String CLASS_NAME = DatabaseMetricGatherer.class.getName();

    /**
     * Logger.
     */
    private static final Logger LOGGER = LoggingHelper.getLogger( CLASS_NAME );

    /**
     * the metric gatherer to fill
     */
    private DirectMetricGather gatherer;

    /**
     * file character set name
     */
    private String charsetName = "UTF-8";

    /**
     * flag used to prevent logging too many warnings when entry logs are
     * missing.
     */
    private boolean firstMissingEntryWarning = true;

    /**
     * flag used to enable or disable parsing of JDBC trace logs provided by
     * WebSphere Application Server.
     */
    private boolean parseJdbcTraceLogs = false;

    /** default timestamp format */
    public static final String DEFAULT_TIMESTAMP_FORMAT = "d/M/yy H:mm:ss:SSS";

    /** timestamp formatter */
    private DateFormat formatter = new SimpleDateFormat( DEFAULT_TIMESTAMP_FORMAT );

    /** default JDBC trace regular expression */
    public static final String DEFAULT_JDBC_TRACE_REGEX = "\\[([0-9]{1,2}/[0-9]{1,2}/[0-9]{2} [0-9]{1,2}:[0-9]{2}:[0-9]{2}:[0-9]{3}) [A-Za-z]{1,3}\\] ([0-9a-fA-F]{8}) JDBCTrace.+?STMT : (.+?) : PARAMETERS\\[(.+?)\\] : Execution time = ([0-9,]*) ms.*";

    /** compiled jdbc trace pattern */
    private Pattern jdbcTracePattern = Pattern.compile( DEFAULT_JDBC_TRACE_REGEX );

    /** default exit trace regular expression */
    public static final String DEFAULT_TRACE_EXIT_REGEX = "\\[([0-9]{1,2}/[0-9]{1,2}/[0-9]{1,2} [0-9]{1,2}:[0-9]{2}:[0-9]{2}:[0-9]{3}) [A-Za-z]{1,3}\\] ([0-9a-fA-F]{8}) .*";

    /** compiled exit trace pattern */
    private Pattern traceExitPattern = Pattern.compile( DEFAULT_TRACE_EXIT_REGEX );

    /**
     * Default entry trace regular expression. Groups : 1 : timestamp 2 : thread
     * ID 3 : ID 4 : parent ID 5 : start time nano
     */
    public static final String DEFAULT_TRACE_ENTRY_REGEX = "\\[([0-9]{1,2}/[0-9]{1,2}/[0-9]{2} [0-9]{1,2}:[0-9]{2}:[0-9]{2}:[0-9]{3}) [A-Za-z]{1,3}\\] ([0-9a-fA-F]{8}) .+?PerfLog <entry.+?id=\"([0-9a-zA-Z ]*)\".+?parentId=\"([0-9a-zA-Z ]*)\".+?startTime=\"([0-9a-zA-Z]*)\".*";

    /** compiled entry trace pattern */
    private Pattern traceEntryPattern = Pattern.compile( DEFAULT_TRACE_ENTRY_REGEX );

    /** Map that stores the execution stack of each thread */
    private static final Map<String, List<OperationMetric>> THREAD_STACK_MAP = new HashMap<String, List<OperationMetric>>();

    /** Used to assign unique IDs to JDBC trace logs that were generated by WAS */
    private static Long idAssigner = Long.MIN_VALUE;

    /**
     * constructor
     */
    public MetricFileLoader() {

    }

    /**
     * get the character set name for the file to parse
     * 
     * @return the character set name for the file to parse
     */
    public String getCharsetName() {
        return charsetName;
    }

    /**
     * set the character set name for the file to parse
     * 
     * @param charsetName
     *            the character set name for the file to parse
     */
    public void setCharsetName( String charsetName ) {
        this.charsetName = charsetName;
    }

    /**
     * the metric gatherer
     * 
     * @return the metric gatherer
     */
    public DirectMetricGather getGatherer() {
        return gatherer;
    }

    /**
     * set the metric gatherer
     * 
     * @param gatherer
     *            the metric gatherer
     */
    public void setGatherer( DirectMetricGather gatherer ) {
        this.gatherer = gatherer;
    }

    /**
     * set Timestamp Format
     * 
     * @param format
     *            the format according to the SimpleDateFormat class.
     * @see SimpleDateFormat
     */
    public void setTimestampFormat( String format ) {
        formatter = new SimpleDateFormat( format );
    }

    /**
     * setExitTraceRegularExpression
     * 
     * @param regex
     *            The regular expression.
     */
    public void setExitTraceRegularExpression( String regex ) {
        traceExitPattern = Pattern.compile( regex );
    }

    /**
     * setEntryTraceRegularExpression
     * 
     * @param regex
     *            The regular expression.
     */
    public void setEntryTraceRegularExpression( String regex ) {
        traceEntryPattern = Pattern.compile( regex );
    }

    /**
     * setJdbcTraceRegularExpression
     * 
     * @param regex
     *            The regular expression.
     */
    public void setJdbcTraceRegularExpression( String regex ) {
        jdbcTracePattern = Pattern.compile( regex );
    }

    /**
     * setParseJdbcTraceLogs
     * 
     * @param parseJdbcTraceLogs
     *            option to parse JDBC Trace logs
     */
    public void setParseJdbcTraceLogs( boolean parseJdbcTraceLogs ) {
        this.parseJdbcTraceLogs = parseJdbcTraceLogs;
    }

    /**
     * Read the content of a file containing serialized operation metrics and
     * store them in the database. Any invalid metric will be ignored.
     * 
     * @param fileName
     *            the file name from which to extract the serialized operation
     *            metrics.
     * @throws Exception
     *             any exception that might occur while reading the file.
     */
    public void gatherMetricsFromFile( String fileName ) throws Exception {
        final String METHODNAME = "fillDatabaseFromFile(String fileName)";
        // boolean isTraceLogEnabled = LoggingHelper.isTraceEnabled(LOGGER);
        boolean entryExitLogEnabled = LoggingHelper.isEntryExitTraceEnabled( LOGGER );

        if ( entryExitLogEnabled ) {
            Object[] params = { fileName };
            LOGGER.entering( CLASS_NAME, METHODNAME, params );
        }

        long start = System.nanoTime();

        FileInputStream fileInputStream = null;
        InputStreamReader inputStreamReader = null;
        BufferedReader bufferedReader = null;

        try {
            File loadFile = new File( fileName );
            if ( loadFile.exists() ) {

                // $ANALYSIS-IGNORE
                fileInputStream = new FileInputStream( fileName );
                // $ANALYSIS-IGNORE
                inputStreamReader = new InputStreamReader( fileInputStream, charsetName );
                // $ANALYSIS-IGNORE
                bufferedReader = new BufferedReader( inputStreamReader );

                readAllLinesFromReader( start, bufferedReader );
            } else {
                LOGGER.log( Level.INFO, "Skipping missing log file : " + fileName );
            }

        } catch ( Exception ex ) {
            LOGGER.log( Level.WARNING, "Failed to parse operation metrics file : " + fileName, ex );
        } finally {
            CacheUtilities.closeQuietly( bufferedReader );
            CacheUtilities.closeQuietly( inputStreamReader );
            CacheUtilities.closeQuietly( fileInputStream );

            if ( entryExitLogEnabled ) {
                Object[] params = { fileName };
                LOGGER.exiting( CLASS_NAME, METHODNAME, params );
            }
        }

    }

    private void readAllLinesFromReader( long startTime, BufferedReader reader ) throws IOException {

        final String METHODNAME = "fillDatabaseFromFile(String fileName)";
        boolean isTraceLogEnabled = LoggingHelper.isTraceEnabled( LOGGER );
        boolean entryExitLogEnabled = LoggingHelper.isEntryExitTraceEnabled( LOGGER );

        if ( entryExitLogEnabled ) {
            Object[] params = { startTime, reader };
            LOGGER.entering( CLASS_NAME, METHODNAME, params );
        }

        String readLine = null;
        int pendingFlushSize = gatherer.getPendingFlushSize();
        int i = 0;
        int logCount = 0;

        while ( ( readLine = reader.readLine() ) != null ) {
            ++i;
            if ( isTraceLogEnabled ) {
                String msg = "Parsing log entry line : " + readLine;
                LOGGER.log( Level.FINE, msg );
            }

            boolean newLog = parseLineAndGatherMetric( readLine );

            if ( newLog ) {
                ++logCount;
            }

            checkToForceDatabaseWrite( pendingFlushSize, i );
        }

        // perform one last write metrics for the remaining data
        gatherer.writeMetrics();

        long duration = ( System.nanoTime() - startTime ) / 1000000;

        LOGGER.log( Level.INFO, "Read " + i + " lines. Wrote : " + logCount + " performance logs to the database in " + duration + "ms." );

        if ( entryExitLogEnabled ) {
            Object[] params = {};
            LOGGER.exiting( CLASS_NAME, METHODNAME, params );
        }
    }

    private void checkToForceDatabaseWrite( int pendingFlushSize, int i ) {
        boolean isTraceLogEnabled = LoggingHelper.isTraceEnabled( LOGGER );
        if ( i % pendingFlushSize == 0 ) {
            if ( isTraceLogEnabled ) {
                String msg = "Parsed log count reached pendingFlushSize of  " + pendingFlushSize + ", forcing write to database.";
                LOGGER.log( Level.FINE, msg );
            }

            gatherer.writeMetrics();
        }
    }

    public boolean parseLineAndGatherMetric( String readLine ) {
        final String METHODNAME = "parseLineAndGatherMetric(String readLine)";
        // boolean isTraceLogEnabled = LoggingHelper.isTraceEnabled(LOGGER);
        boolean entryExitLogEnabled = LoggingHelper.isEntryExitTraceEnabled( LOGGER );
        if ( entryExitLogEnabled ) {
            Object[] params = { readLine };
            LOGGER.entering( CLASS_NAME, METHODNAME, params );
        }

        boolean newLog = false;
        OperationMetric metric = parseLine( readLine );
        if ( metric != null ) {
            gatherer.gatherMetric( metric );
            newLog = true;

            processTraceExit( readLine, metric );

        } else if ( parseJdbcTraceLogs ) {
            try {
                Matcher matcher = jdbcTracePattern.matcher( readLine );
                if ( matcher.find() ) {
                    processJdbcTrace( matcher );
                    newLog = true;
                } else {
                    Matcher entryMatcher = traceEntryPattern.matcher( readLine );
                    if ( entryMatcher.find() ) {
                        processEntryTrace( entryMatcher );
                    }
                }
            } catch ( Exception e ) {
                LoggingHelper.logUnexpectedException( LOGGER, CLASS_NAME, METHODNAME, e );
            }
        }

        if ( entryExitLogEnabled ) {
            LOGGER.exiting( CLASS_NAME, METHODNAME, newLog );
        }
        return newLog;
    }

    private void processEntryTrace( Matcher matcher ) throws ParseException {
        final String METHODNAME = "processEntryTrace(Matcher matcher) throws ParseException";
        // boolean isTraceLogEnabled = LoggingHelper.isTraceEnabled(LOGGER);
        boolean entryExitLogEnabled = LoggingHelper.isEntryExitTraceEnabled( LOGGER );
        if ( entryExitLogEnabled ) {
            Object[] params = { matcher };
            LOGGER.entering( CLASS_NAME, METHODNAME, params );
        }

        OperationMetric metric = new OperationMetric();
        String timestamp = matcher.group( 1 );
        long startTimeMilli = parseLogTimeStamp( timestamp );
        String threadId = matcher.group( 2 );
        String idString = matcher.group( 3 );
        String parentIdString = matcher.group( 4 );
        String startTimeNanoString = matcher.group( 5 );

        long id = Long.parseLong( idString );
        long parentId = Long.parseLong( parentIdString );
        metric.setIdentifier( id );
        metric.setParentIdentifier( parentId );
        long startTimeNano = Long.parseLong( startTimeNanoString );
        metric.setStartTime( startTimeNano );

        // temporarily store the milli start time in the duration field
        metric.setDuration( startTimeMilli );

        List<OperationMetric> list = THREAD_STACK_MAP.get( threadId );
        OperationMetric metricParent = null;
        if ( list == null ) {
            list = new ArrayList<OperationMetric>();
            THREAD_STACK_MAP.put( threadId, list );
        } else if ( list.size() > 0 ) {
            metricParent = list.get( list.size() - 1 );
        }
        list.add( metric );

        if ( parentId != 0 ) {
            if ( metricParent == null || metricParent.getIdentifier() != parentId ) {
                String msg = "Failed to find metric parent in thread : " + threadId + ". ID : " + id + ", expected parent ID : " + parentId;
                LOGGER.logp( Level.WARNING, CLASS_NAME, METHODNAME, msg );
            }
        }
        if ( entryExitLogEnabled ) {
            LOGGER.exiting( CLASS_NAME, METHODNAME );
        }
    }

    private void processJdbcTrace( Matcher matcher ) throws ParseException {

        final String METHODNAME = "processJdbcTrace(Matcher matcher)";
        // boolean isTraceLogEnabled = LoggingHelper.isTraceEnabled(LOGGER);
        boolean entryExitLogEnabled = LoggingHelper.isEntryExitTraceEnabled( LOGGER );
        if ( entryExitLogEnabled ) {
            Object[] params = { matcher };
            LOGGER.entering( CLASS_NAME, METHODNAME, params );
        }

        OperationMetric metric;
        String timestamp = matcher.group( 1 );
        long stopTimeMilli = parseLogTimeStamp( timestamp );
        String threadId = matcher.group( 2 );
        String statement = matcher.group( 3 );
        String parameters = matcher.group( 4 );
        String durationString = matcher.group( 5 );
        long durationMilli = Long.parseLong( durationString );
        long startTimeMilli = stopTimeMilli - durationMilli;

        List<OperationMetric> list = THREAD_STACK_MAP.get( threadId );
        OperationMetric metricParent = null;
        if ( list != null && list.size() > 0 ) {
            metricParent = list.get( list.size() - 1 );
        }

        metric = new OperationMetric();

        List<String> parameterList = Arrays.asList( new String[] { parameters } );
        metric.setKeyValuePairList( parameterList );
        metric.setOperationCacheEnabled( false );
        metric.setOperationName( "JDBCTrace : " + statement );
        metric.setIdentifier( idAssigner++ );
        metric.setResultFetchedFromCache( false );
        metric.setResultSize( 1000 );

        long durationNano = durationMilli * 1000000;
        if ( metricParent == null ) {
            // standalone SQL statement with no parent.
            metric.setDuration( durationNano );
            metric.setStartTime( startTimeMilli * 1000000 );
            metric.setStopTime( stopTimeMilli * 1000000 );
        } else {
            metric.setParentIdentifier( metricParent.getIdentifier() );

            long parentStartTimeMilli = metricParent.getDuration();
            long parentStartTimeNano = metricParent.getStartTime();

            long startDeltaMilli = startTimeMilli - parentStartTimeMilli;

            if ( startDeltaMilli < -2 ) {
                String msg = "Found JDBC trace that starts " + startDeltaMilli + " ms after it's parent start";
                LOGGER.logp( Level.WARNING, CLASS_NAME, METHODNAME, msg );
            }

            // use stop time to increment a counter to ensure nobody uses the
            // exact same start time.
            metricParent.setStopTime( metricParent.getStopTime() + 1 );
            long startTimeNano = parentStartTimeNano + startDeltaMilli * 1000000 + metricParent.getStopTime();
            long stopTimeNano = startTimeNano + durationNano;
            // adjust timing & order based on parent
            metric.setDuration( durationNano );
            metric.setStartTime( startTimeNano );
            metric.setStopTime( stopTimeNano );
        }

        gatherer.gatherMetric( metric );

        if ( entryExitLogEnabled ) {
            LOGGER.exiting( CLASS_NAME, METHODNAME );
        }
    }

    private boolean failedToParseExitLog = false;

    private void processTraceExit( String readLine, OperationMetric metric ) {
        final String METHODNAME = " processTraceExit(String readLine, OperationMetric metric)";
        // boolean isTraceLogEnabled = LoggingHelper.isTraceEnabled(LOGGER);
        boolean entryExitLogEnabled = LoggingHelper.isEntryExitTraceEnabled( LOGGER );
        if ( entryExitLogEnabled ) {
            Object[] params = { readLine, metric };
            LOGGER.entering( CLASS_NAME, METHODNAME, params );
        }

        if ( !parseJdbcTraceLogs ) {
            // feature disabled
            return;
        }

        try {
            Matcher matcher = traceExitPattern.matcher( readLine );
            if ( matcher.find() ) {
                // String timestamp = matcher.group(1);
                // long stopTime = parseLogTimeStamp(timestamp);
                String threadId = matcher.group( 2 );

                List<OperationMetric> list = THREAD_STACK_MAP.get( threadId );
                boolean missingEntry = true;
                if ( list != null && list.size() > 0 ) {
                    int lastIndex = list.size() - 1;
                    OperationMetric metricParent = list.get( lastIndex );
                    if ( metricParent.getIdentifier() == metric.getIdentifier() ) {
                        // entry/exit match
                        list.remove( lastIndex );
                        missingEntry = false;
                    }

                }

                if ( missingEntry ) {
                    String missingLogMessage = "Found exit log without entry log. ID : ";
                    if ( firstMissingEntryWarning ) {
                        firstMissingEntryWarning = false;
                        String futureMessage = " Future missing entry logs will be logged at the FINER level. To remove this warning, please ensure that all exit logs have a matching entry log. This is usually done by setting the service logger level to FINER instead of the FINE level. If you don't use WebSphere Application Server JDBC traces, you can also prevent his warning by setting parseWasJdbcTrace=false in your configuration file.";
                        String msg = missingLogMessage + metric.getIdentifier() + "." + futureMessage;
                        LOGGER.logp( Level.WARNING, CLASS_NAME, METHODNAME, msg );
                    } else {
                        String msg = missingLogMessage + metric.getIdentifier() + ".";
                        LOGGER.logp( Level.FINER, CLASS_NAME, METHODNAME, msg );
                    }
                }
            } else {
                String failedToParseExitLogMessage = "Failed to parse timestamp and thread ID of log line : ";
                if ( failedToParseExitLog ) {
                    String msg = failedToParseExitLogMessage + readLine;
                    LOGGER.log( Level.FINER, msg );
                } else {
                    failedToParseExitLog = true;
                    String msg = failedToParseExitLogMessage
                        + readLine
                        + ". Future errors will be logged under the FINER level. If your logs don't match the WebSphere Application Server 7.0 log format, you can remove this warning by setting the property : parseWasJdbcTrace=false in your configuration file.";
                    LOGGER.log( Level.WARNING, msg );
                }
            }
        } catch ( Exception e ) {
            LoggingHelper.logUnexpectedException( LOGGER, CLASS_NAME, METHODNAME, e );
        }

        if ( entryExitLogEnabled ) {
            LOGGER.exiting( CLASS_NAME, METHODNAME );
        }
    }

    public long parseLogTimeStamp( String timestamp ) throws ParseException {
        long stopTime = 0;
        Date parse = formatter.parse( timestamp );
        stopTime = parse.getTime();
        return stopTime;
    }

    /**
     * parse a line of performance metric
     * 
     * @param readLine
     *            the raw data
     * @return the parsed metric, null if the line wasn't valid.
     */
    public OperationMetric parseLine( String readLine ) {
        if ( readLine == null ) {
            return null;
        }
        OperationMetric metric = new OperationMetric();
        boolean success = metric.fromSerializedString( readLine );
        if ( success ) {
            adjustJdbcMetric(metric);
            adjustCassandraMetric(metric);
            return metric;
        } else {
            return null;
        }
    }

    public static void adjustCassandraMetric(OperationMetric metric)
    {
        String operationName = metric.getOperationName();
        if( operationName == null) {
            return;
        }
        
        if( ! operationName.startsWith("Cassandra")) 
        {
            return;
        }
        
        String newOperationName= substituteCassandraParameters(operationName);
        
        ArrayList<String> parameters = new ArrayList<String>(metric.getKeyValuePairList());
        
        addCassandraParameterSubstitution(operationName, parameters);
        
        metric.setOperationName(newOperationName);
        metric.setKeyValuePairList(parameters);
    }

    public static void adjustJdbcMetric(OperationMetric metric)
    {
        String operationName = metric.getOperationName();
        if( operationName == null) {
            return;
        }
        
        if( ! operationName.startsWith("JDBC")) 
        {
            return;
        }
        
        String newOperationName= substituteJdbcParameters(operationName);
        
        ArrayList<String> parameters = new ArrayList<String>(metric.getKeyValuePairList());
        
        addJdbcParameterSubstitution(operationName, parameters);
        
        metric.setOperationName(newOperationName);
        metric.setKeyValuePairList(parameters);
    }

    /**
     * Take a SQL and extract all the textual and numerical values to make them
     * parameters.
     * 
     * @param operationName
     *            The SQL
     * @param asList
     *            The list of operations to fill where the list contains two
     *            entries for each parameter, the first is the parameter name,
     *            the second is the parameter string value.
     */
    public static void addJdbcParameterSubstitution(String operationName, List<String> asList)
    {
        Matcher matcher = PARAMETER_SUBSTITUTION.matcher(operationName);

        int count = 1;
        while (matcher.find())
        {
            asList.add("*" + count++);
            asList.add(matcher.group());
        }
    }
    
    /**
     * Take a SQL and extract all the textual and numerical values to make them
     * parameters.
     * 
     * @param operationName
     *            The SQL
     * @param asList
     *            The list of operations to fill where the list contains two
     *            entries for each parameter, the first is the parameter name,
     *            the second is the parameter string value.
     */
    public static void addCassandraParameterSubstitution(String operationName, List<String> asList)
    {
        Matcher matcher = CASSANDRA_PARAMETER_SUBSTITUTION.matcher(operationName);

        int count = 1;
        while (matcher.find())
        {
            asList.add("*" + count++);
            asList.add(matcher.group());
        }
    }    

    /**
     * Substitute all the SQL numeric and textual parameters for a parameter
     * marker. It also regroups the parameters in a group so that the variable
     * length list will show up as one "**?" parameter)
     * 
     * @param operationName
     *            The SQL with numeric and textual parameters
     * @return The SQL with numeric and textual parameters substituted with
     *         markers
     */
	public static String substituteJdbcParameters(String operationName) {
		try {
			Matcher matcher = PARAMETER_SUBSTITUTION.matcher(operationName);
			String substitutedSql = matcher.replaceAll("*?");

			Matcher matcher2 = PARAMETER_LIST_SUBSTITUTION
					.matcher(substitutedSql);
			return matcher2.replaceAll("(**?)");
		} catch (Exception ex) {
			LoggingHelper.logUnexpectedException(LOGGER, CLASS_NAME,
					"substituteJdbcParameters", ex);
			return operationName;
		}
	}
    
    /**
     * Substitute all the CQL numeric and textual parameters for a parameter
     * marker. It also regroups the parameters in a group so that the variable
     * length list will show up as one "**?" parameter)
     * 
     * @param operationName
     *            The CQL with numeric and textual parameters
     * @return The CQL with numeric and textual parameters substituted with
     *         markers
     */
	protected static String substituteCassandraParameters(String operationName) {
		try {
			Matcher matcher = CASSANDRA_PARAMETER_SUBSTITUTION
					.matcher(operationName);
			String substitutedSql = matcher.replaceAll("*?");

			Matcher matcher2 = PARAMETER_LIST_SUBSTITUTION
					.matcher(substitutedSql);
			return matcher2.replaceAll("(**?)");
		} catch (Exception ex) {
			LoggingHelper.logUnexpectedException(LOGGER, CLASS_NAME,
					"substituteJdbcParameters", ex);
			return operationName;
		}
	}

    private static final Pattern PARAMETER_SUBSTITUTION = Pattern.compile("(" + QUOTED_STRING_REGEX + "|" +
        NUMBER_REGEX + ")");

    private static final Pattern PARAMETER_LIST_SUBSTITUTION = Pattern.compile("\\( *\\*?\\? *,[ ,\\*\\?]*\\)");
    
    private static final Pattern CASSANDRA_PARAMETER_SUBSTITUTION = Pattern.compile("(" + QUOTED_STRING_REGEX + "|" +
        NUMBER_REGEX + "|" + UUID_REGEX + ")");

}
